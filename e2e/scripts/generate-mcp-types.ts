#!/usr/bin/env tsx
/**
 * è‡ªåŠ¨ç”Ÿæˆ MCP Tools çš„ TypeScript ç±»å‹å®šä¹‰
 * 
 * å®Œå…¨åŸºäºè¿è¡Œæ—¶ toolRegistry æ•°æ®ç”Ÿæˆç±»å‹ï¼Œä¸è¯»å–æºç 
 * å‚è€ƒ mcp.middleware.ts çš„å®ç°æ–¹å¼
 * 
 * å¯¹äºå¤æ‚çš„é€’å½’ schemaï¼ˆz.lazyï¼‰ï¼Œä» schema æ–‡ä»¶ä¸­æ‰«æå¹¶å¯¼å…¥å·²å®šä¹‰çš„ç±»å‹
 */

import * as fs from 'fs';
import * as path from 'path';
import * as glob from 'glob';
import { scanToolsFromRegistry, ExtendedToolInfo } from './tool-utils';

interface ToolInfo {
    toolName: string;
    methodName: string;
    title?: string;
    description?: string;
    paramsTypeName: string;
    resultTypeName: string;
}

/**
 * Schema åˆ° Type çš„æ˜ å°„
 * ä» schema æ–‡ä»¶ä¸­æ‰«æ SchemaXxx -> TXxx çš„æ˜ å°„å…³ç³»
 */
interface SchemaTypeMapping {
    schemaName: string;  // ä¾‹å¦‚: SchemaCreatedAssetResult
    typeName: string;    // ä¾‹å¦‚: TCreatedAssetResult
    importPath: string;  // ä¾‹å¦‚: ../../dist/api/assets/schema
}

/**
 * æ‰«ææ‰€æœ‰ schema æ–‡ä»¶ï¼Œå»ºç«‹ Schema åˆ° Type çš„æ˜ å°„
 * æŸ¥æ‰¾æ‰€æœ‰ export type TXxx = z.infer<typeof SchemaXxx> çš„å®šä¹‰
 */
function scanSchemaTypeMappings(): Map<string, SchemaTypeMapping> {
    const mappings = new Map<string, SchemaTypeMapping>();
    
    // æŸ¥æ‰¾æ‰€æœ‰ schema æ–‡ä»¶ï¼ˆä»¥ schema ç»“å°¾çš„ ts æ–‡ä»¶ï¼‰
    const schemaFiles = glob.sync('src/api/**/*schema*.ts', {
        absolute: true,
    });

    for (const schemaFile of schemaFiles) {
        const content = fs.readFileSync(schemaFile, 'utf-8');
        
        // åŒ¹é… export type TXxx = z.infer<typeof SchemaXxx>
        const inferPattern = /export\s+type\s+(T\w+)\s*=\s*z\.infer<typeof\s+(Schema\w+)>/g;
        let match;
        
        while ((match = inferPattern.exec(content)) !== null) {
            const typeName = match[1];
            const schemaName = match[2];
            
            // è®¡ç®—å¯¼å…¥è·¯å¾„ï¼ˆä» e2e/types åˆ° dist/api/xxx/schemaï¼‰
            const distPath = schemaFile
                .replace(/\\/g, '/')
                .replace(/^.*\/src\//, 'dist/')
                .replace(/\.ts$/, '');
            const importPath = path.relative(
                path.resolve(process.cwd(), 'e2e/types'),
                path.resolve(process.cwd(), distPath)
            ).replace(/\\/g, '/');
            
            mappings.set(schemaName, {
                schemaName,
                typeName,
                importPath,
            });
        }
    }
    
    return mappings;
}

/**
 * ç”Ÿæˆ TypeScript ç±»å‹å®šä¹‰
 */
function generateTypeDefinitions(tools: ToolInfo[], typeBlocks: string[], importsByPath: Map<string, Set<string>>): string {
    const lines: string[] = [];

    // æ–‡ä»¶å¤´éƒ¨
    lines.push('/**');
    lines.push(' * MCP Tools Type Definitions');
    lines.push(' * ');
    lines.push(' * ğŸ¤– This file is auto-generated by e2e/scripts/generate-mcp-types.ts');
    lines.push(' * DO NOT EDIT MANUALLY');
    lines.push(' * ');
    lines.push(' * To regenerate: npm run generate:mcp-types');
    lines.push(' * ');
    lines.push(' * åŸºäºè¿è¡Œæ—¶ toolRegistry æ•°æ®ç”Ÿæˆï¼Œå®Œå…¨ä½¿ç”¨ zod-to-ts ä» Zod Schema è½¬æ¢');
    lines.push(' */');
    lines.push('');

    // MCP Response ç±»å‹
    lines.push('// MCP Response wrapper');
    lines.push('export interface MCPResponse<T = any> {');
    lines.push('    code: number;');
    lines.push('    data: T;');
    lines.push('    reason?: string;');
    lines.push('}');
    lines.push('');

    // ç”Ÿæˆå¯¼å…¥è¯­å¥ï¼ˆå¦‚æœæœ‰ä» schema æ–‡ä»¶å¯¼å…¥çš„ç±»å‹ï¼‰
    if (importsByPath && importsByPath.size > 0) {
        lines.push('// Import types from schema files (for complex recursive schemas)');
        for (const [importPath, types] of importsByPath.entries()) {
            const typeList = Array.from(types).sort();
            if (typeList.length === 1) {
                lines.push(`import type { ${typeList[0]} } from '${importPath}';`);
            } else {
                lines.push(`import type {`);
                typeList.forEach(type => {
                    lines.push(`    ${type},`);
                });
                lines.push(`} from '${importPath}';`);
            }
        }
        lines.push('');
    }

    // æ·»åŠ ä» zod-to-ts ç”Ÿæˆçš„ç±»å‹å—ï¼Œå¹¶ç¡®ä¿å®ƒä»¬éƒ½æ˜¯ export type
    if (typeBlocks.length > 0) {
        lines.push('// Tool parameter and result types (generated from Zod schemas)');
        lines.push('// These types are automatically generated from runtime Zod schemas using zod-to-ts');
        lines.push('// DO NOT manually edit these type definitions');
        lines.push('');
        typeBlocks.forEach(block => {
            // å°† type æ”¹ä¸º export typeï¼Œç¡®ä¿ç±»å‹å¯ä»¥è¢«å¯¼å‡ºä½¿ç”¨
            // ä½¿ç”¨å¤šè¡ŒåŒ¹é…ï¼Œå¤„ç†å¯èƒ½çš„å¤šè¡Œ type å®šä¹‰
            // åŒ¹é…æ¨¡å¼ï¼šè¡Œé¦–çš„ "type " æ›¿æ¢ä¸º "export type "
            let exportedBlock = block.replace(/^type\s+/gm, 'export type ');
            // å°†åŒå¼•å·æ›¿æ¢ä¸ºå•å¼•å·ï¼ˆzod-to-ts é»˜è®¤ä½¿ç”¨åŒå¼•å·ï¼‰
            exportedBlock = exportedBlock.replace(/"/g, "'");
            lines.push(exportedBlock);
            lines.push('');
        });
    }

    // ç”Ÿæˆå·¥å…·æ˜ å°„è¡¨
    lines.push('/**');
    lines.push(' * MCP Tools ç±»å‹æ˜ å°„è¡¨');
    lines.push(' * ');
    lines.push(' * ä½¿ç”¨æ–¹å¼ï¼š');
    lines.push(' * ```typescript');
    lines.push(' * const result = await mcpClient.callTool(\'assets-create-asset\', {');
    lines.push(' *   options: { target: \'db://assets/test.txt\' }');
    lines.push(' * });');
    lines.push(' * // result çš„ç±»å‹ä¼šè‡ªåŠ¨æ¨æ–­ä¸º MCPResponse<AssetsCreateAssetResult>');
    lines.push(' * ```');
    lines.push(' */');
    lines.push('export interface MCPToolsMap {');

    tools.forEach(tool => {
        if (tool.title || tool.description) {
            lines.push('');
            lines.push('    /**');
            if (tool.title) {
                lines.push(`     * ${tool.title}`);
            }
            if (tool.description) {
                lines.push(`     * ${tool.description}`);
            }
            lines.push('     */');
        }

        // ç›´æ¥ä½¿ç”¨ zod-to-ts ç”Ÿæˆçš„ç±»å‹åç§°
        const paramType = tool.paramsTypeName;
        const returnType = tool.resultTypeName;

        lines.push(`    '${tool.toolName}': {`);
        lines.push(`        params: ${paramType};`);
        lines.push(`        result: ${returnType};`);
        lines.push('    };');
    });

    lines.push('}');
    lines.push('');

    // å·¥å…·åç§°è”åˆç±»å‹
    lines.push('// Tool name union type');
    lines.push('export type MCPToolName = keyof MCPToolsMap;');
    lines.push('');

    // å¯¼å‡ºå·¥å…·åˆ—è¡¨ï¼ˆæ–¹ä¾¿è¿è¡Œæ—¶ä½¿ç”¨ï¼‰
    lines.push('// Available tools list');
    lines.push('export const MCP_TOOLS: MCPToolName[] = [');
    tools.forEach(tool => {
        lines.push(`    '${tool.toolName}',`);
    });
    lines.push('];');
    lines.push('');

    // ç»Ÿè®¡ä¿¡æ¯
    lines.push('/**');
    lines.push(' * ç”Ÿæˆç»Ÿè®¡:');
    lines.push(` * - æ€»å·¥å…·æ•°: ${tools.length}`);
    lines.push(` * - ç”Ÿæˆæ—¶é—´: ${new Date().toISOString()}`);
    lines.push(' */');

    return lines.join('\n');
}

/**
 * å°† kebab-case è½¬æ¢ä¸º PascalCase
 */
function toPascalCase(str: string): string {
    return str
        .split('-')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join('');
}

/**
 * åŸºäºè¿è¡Œæ—¶æ³¨å†Œä¿¡æ¯ï¼ˆZod Schemaï¼‰ç›´æ¥ç”Ÿæˆ TS ç±»å‹å®šä¹‰
 * å®Œå…¨å‚è€ƒ mcp.middleware.ts çš„å®ç°æ–¹å¼ï¼Œä½¿ç”¨ zod-to-ts ä» schema ç”Ÿæˆç±»å‹
 * å¯¹äºå¤æ‚çš„é€’å½’ schemaï¼Œå°è¯•ä» schema æ˜ å°„ä¸­æŸ¥æ‰¾å¯¹åº”çš„ç±»å‹åç§°
 */
async function generateTypesFromRuntimeSchemas(
    tools: ExtendedToolInfo[],
    schemaMappings: Map<string, SchemaTypeMapping>
): Promise<{ tools: ToolInfo[]; typeBlocks: string[]; importsByPath: Map<string, Set<string>> }> {
    const { z } = await import('zod');
    // @ts-ignore - zod-to-ts v1.1.4 å¯èƒ½æ²¡æœ‰å®Œæ•´çš„ç±»å‹å®šä¹‰
    const { zodToTs, printNode, createTypeAlias } = await import('zod-to-ts');
    
    const resultTools: ToolInfo[] = [];
    const allTypeBlocks: string[] = [];
    const importsByPath = new Map<string, Set<string>>();

    for (const tool of tools) {
        const typeBlocks: string[] = [];
        let paramsTypeName = 'Record<string, never>';
        let resultTypeName = 'any';

        // ä» paramSchemas æ„å»ºè¾“å…¥ schemaï¼ˆå‚è€ƒ mcp.middleware.ts:78-85ï¼‰
        if (tool.paramSchemas && tool.paramSchemas.length > 0) {
            try {
                const typeName = toPascalCase(tool.toolName) + 'Params';
                
                // æ„å»ºè¾“å…¥å¯¹è±¡ schemaï¼ˆä¸ mcp.middleware.ts ä¸­çš„é€»è¾‘å®Œå…¨ä¸€è‡´ï¼‰
                const inputSchemaFields: Record<string, any> = {};
                tool.paramSchemas
                    .sort((a, b) => a.index - b.index)
                    .forEach((param) => {
                        if (param.name) {
                            inputSchemaFields[param.name] = param.schema;
                        }
                    });

                // å¦‚æœæœ‰å­—æ®µï¼Œæ„å»º z.object schema
                if (Object.keys(inputSchemaFields).length > 0) {
                    const inputSchema = z.object(inputSchemaFields);
                    // zod-to-ts v1.1.4 API: zodToTs(schema, typeName) è¿”å› { node, store }
                    const { node } = zodToTs(inputSchema, typeName);
                    // åˆ›å»ºç±»å‹åˆ«å
                    const typeAlias = createTypeAlias(node, typeName);
                    typeBlocks.push(printNode(typeAlias));
                    paramsTypeName = typeName;
                }
            } catch (error) {
                console.warn(`âš ï¸  ç”Ÿæˆ ${tool.toolName} Params ç±»å‹å¤±è´¥:`, error);
                paramsTypeName = 'Record<string, never>';
            }
        }

        // ç”Ÿæˆ Result ç±»å‹ï¼ˆå‚è€ƒ mcp.middleware.ts:88ï¼‰
        // æ³¨æ„ï¼šreturnSchema å·²ç»è¢« createCommonResult åŒ…è£…ï¼ŒåŒ…å« { code, data, reason }
        // ä½† MCPResponse å·²ç»åŒ…è£…äº†è¿™äº›å­—æ®µï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æå– data å­—æ®µçš„ç±»å‹
        if (tool.returnSchema) {
            try {
                const typeName = toPascalCase(tool.toolName) + 'Result';
                
                // å°è¯•ä» returnSchema ä¸­æå– data å­—æ®µçš„ schema
                // returnSchema æ˜¯ createCommonResult(originalSchema) çš„ç»“æœ
                // ç»“æ„æ˜¯: { code: ..., data: originalSchema | undefined, reason: ... }
                let dataSchema: any = tool.returnSchema;
                
                // å¦‚æœ returnSchema æ˜¯ z.objectï¼Œå°è¯•æå– data å­—æ®µ
                if (tool.returnSchema && typeof tool.returnSchema === 'object' && '_def' in tool.returnSchema) {
                    const def = (tool.returnSchema as any)._def;
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ z.object
                    if (def && def.typeName === 'ZodObject') {
                        const shape = def.shape();
                        if (shape && shape.data) {
                            // æå– data å­—æ®µçš„ schema
                            dataSchema = shape.data;
                            // data å¯èƒ½æ˜¯ z.union([originalSchema, z.undefined()])
                            // éœ€è¦æå– union ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼ˆåŸå§‹ schemaï¼‰
                            if (dataSchema && dataSchema._def && dataSchema._def.typeName === 'ZodUnion') {
                                const options = dataSchema._def.options;
                                if (options && options.length > 0) {
                                    // æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸æ˜¯ undefined çš„é€‰é¡¹
                                    dataSchema = options.find((opt: any) => 
                                        opt._def && opt._def.typeName !== 'ZodUndefined'
                                    ) || options[0];
                                }
                            }
                        }
                    }
                }
                
                // å¤„ç† z.lazy() schemaï¼šå±•å¼€å®ƒ
                if (dataSchema && dataSchema._def && dataSchema._def.typeName === 'ZodLazy') {
                    try {
                        // è°ƒç”¨ getter å‡½æ•°å±•å¼€ lazy schema
                        dataSchema = dataSchema._def.getter();
                    } catch {
                        // å¦‚æœå±•å¼€å¤±è´¥ï¼Œä½¿ç”¨ anyï¼Œä½†ç»§ç»­å¤„ç†è¯¥å·¥å…·
                        console.warn(`âš ï¸  ${tool.toolName} Result ç±»å‹å±•å¼€ lazy schema å¤±è´¥ï¼Œä½¿ç”¨ any`);
                        resultTypeName = 'any';
                        // ä¸ continueï¼Œç»§ç»­å¤„ç†è¯¥å·¥å…·
                    }
                }
                
                // å¤„ç† z.nullable()ï¼šæå–å†…éƒ¨ç±»å‹
                if (dataSchema && dataSchema._def && dataSchema._def.typeName === 'ZodNullable') {
                    dataSchema = dataSchema._def.innerType;
                }
                
                // åªæœ‰åœ¨ resultTypeName è¿˜æ˜¯åˆå§‹å€¼ 'any' æ—¶æ‰å°è¯•ç”Ÿæˆç±»å‹
                // å¦‚æœä¹‹å‰å·²ç»è®¾ç½®ä¸º 'any'ï¼ˆå› ä¸º lazy schema å±•å¼€å¤±è´¥ï¼‰ï¼Œåˆ™è·³è¿‡ç±»å‹ç”Ÿæˆ
                if (resultTypeName === 'any' && dataSchema && dataSchema._def && dataSchema._def.typeName === 'ZodLazy') {
                    // lazy schema å±•å¼€å¤±è´¥ï¼Œå·²ç»è®¾ç½®ä¸º anyï¼Œè·³è¿‡ç±»å‹ç”Ÿæˆ
                } else if (resultTypeName !== 'any' || !dataSchema || !dataSchema._def || dataSchema._def.typeName !== 'ZodLazy') {
                    // ä½¿ç”¨æå–çš„ dataSchema ç”Ÿæˆç±»å‹
                    try {
                        const { node } = zodToTs(dataSchema, typeName);
                        // åˆ›å»ºç±»å‹åˆ«å
                        const typeAlias = createTypeAlias(node, typeName);
                        const generatedType = printNode(typeAlias);
                        
                        // æ£€æŸ¥æ˜¯å¦æœ‰å¾ªç¯å¼•ç”¨ï¼ˆç±»å‹åç§°å‡ºç°åœ¨ç±»å‹å®šä¹‰ä¸­ï¼‰
                        const typeDefMatch = generatedType.match(/type\s+(\w+)\s*=\s*(.+);/s);
                        if (typeDefMatch) {
                            const [, typeNameInDef, typeBody] = typeDefMatch;
                            // å¦‚æœç±»å‹ä½“åªåŒ…å«ç±»å‹åç§°æœ¬èº«ï¼ˆå¾ªç¯å¼•ç”¨ï¼‰ï¼Œä½¿ç”¨ any
                            if (typeBody.trim() === typeNameInDef || 
                                typeBody.trim() === `${typeNameInDef} | null` ||
                                typeBody.trim() === `${typeNameInDef}[]`) {
                                console.warn(`âš ï¸  ${tool.toolName} Result ç±»å‹å­˜åœ¨å¾ªç¯å¼•ç”¨ï¼Œä½¿ç”¨ any`);
                                resultTypeName = 'any';
                                // ä¸æ·»åŠ ç±»å‹å—ï¼Œç»§ç»­å¤„ç†è¯¥å·¥å…·ï¼Œç¡®ä¿å·¥å…·è¢«æ·»åŠ åˆ°ç»“æœä¸­
                            } else {
                                // ç±»å‹ç”ŸæˆæˆåŠŸï¼Œæ·»åŠ åˆ°ç±»å‹å—ä¸­
                                typeBlocks.push(generatedType);
                                resultTypeName = typeName;
                            }
                        } else {
                            // æ— æ³•è§£æç±»å‹å®šä¹‰ï¼Œç›´æ¥ä½¿ç”¨ç”Ÿæˆçš„ç±»å‹
                            typeBlocks.push(generatedType);
                            resultTypeName = typeName;
                        }
                    } catch (genError) {
                        console.warn(`âš ï¸  ç”Ÿæˆ ${tool.toolName} Result ç±»å‹å¤±è´¥:`, genError);
                        resultTypeName = 'any';
                    }
                }
            } catch (error) {
                console.warn(`âš ï¸  ç”Ÿæˆ ${tool.toolName} Result ç±»å‹å¤±è´¥:`, error);
                resultTypeName = 'any';
            }
        }

        resultTools.push({
            toolName: tool.toolName,
            methodName: tool.methodName,
            title: tool.title,
            description: tool.description,
            paramsTypeName,
            resultTypeName,
        });

        allTypeBlocks.push(...typeBlocks);
    }

    return { tools: resultTools, typeBlocks: allTypeBlocks, importsByPath };
}

/**
 * ä¸»å‡½æ•°
 * å®Œå…¨åŸºäºè¿è¡Œæ—¶ toolRegistry æ•°æ®ç”Ÿæˆç±»å‹ï¼Œä¸è¯»å–æºç 
 */
async function main() {
    console.log('ğŸ¤– å¼€å§‹ç”Ÿæˆ MCP Tools ç±»å‹å®šä¹‰ï¼ˆåŸºäºè¿è¡Œæ—¶æ•°æ®ï¼‰...\n');

    // æ­¥éª¤ 1: ä½¿ç”¨ toolRegistry æ‰«æå·²æ³¨å†Œçš„å·¥å…·ï¼ˆå‚è€ƒ mcp.middleware.tsï¼‰
    console.log('ğŸ” æ‰«æ MCP API å·¥å…·å®šä¹‰ (é€šè¿‡ toolRegistry)...\n');
    const toolsFromRegistry = await scanToolsFromRegistry();
    console.log(`âœ… æ‰¾åˆ° ${toolsFromRegistry.length} ä¸ª MCP å·¥å…·\n`);

    // æ­¥éª¤ 2: æ‰«æ schema æ–‡ä»¶ï¼Œå»ºç«‹æ˜ å°„ï¼ˆç”¨äºå¤„ç†å¾ªç¯å¼•ç”¨ï¼‰
    const schemaMappings = scanSchemaTypeMappings();

    // æ­¥éª¤ 3: åŸºäºè¿è¡Œæ—¶ Zod Schema ç”Ÿæˆ TS ç±»å‹ï¼ˆå‚è€ƒ mcp.middleware.ts çš„å®ç°ï¼‰
    console.log('ğŸ“ ä» Zod Schema ç”Ÿæˆ TypeScript ç±»å‹...\n');
    const { tools, typeBlocks, importsByPath } = await generateTypesFromRuntimeSchemas(toolsFromRegistry, schemaMappings);
    console.log(`âœ… ç”Ÿæˆäº† ${typeBlocks.length} ä¸ªç±»å‹å®šä¹‰å—\n`);

    // æ­¥éª¤ 4: ç”Ÿæˆå®Œæ•´çš„ç±»å‹å®šä¹‰æ–‡ä»¶
    console.log('ğŸ“„ ç”Ÿæˆç±»å‹å®šä¹‰æ–‡ä»¶...\n');
    const typeDefinitions = generateTypeDefinitions(tools, typeBlocks, importsByPath);

    // æ­¥éª¤ 4: å†™å…¥æ–‡ä»¶
    const outputPath = path.resolve(process.cwd(), 'e2e/types/mcp-tools.generated.ts');
    const outputDir = path.dirname(outputPath);

    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }

    fs.writeFileSync(outputPath, typeDefinitions, 'utf-8');
    console.log(`âœ¨ ç±»å‹å®šä¹‰å·²ç”Ÿæˆ: ${path.relative(process.cwd(), outputPath)}\n`);
}

// è¿è¡Œè„šæœ¬
main().catch(error => {
    console.error('âŒ ç”Ÿæˆå¤±è´¥:', error);
    process.exit(1);
});

